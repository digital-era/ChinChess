<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>优雅的中国象棋 Web 版</title>
    <style>
        :root {
            --board-bg: #e4c594;
            --line-color: #5c3a21;
            --red-piece: #c0392b;
            --black-piece: #2c3e50;
            --piece-bg: radial-gradient(circle at 15px 15px, #fff8e7, #e6d1a1);
        }
        body {
            font-family: -apple-system, "PingFang SC", "Microsoft YaHei", sans-serif;
            background-color: #f4f4f9;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }
        h1 { color: #333; margin-bottom: 5px; }
        .status-bar { margin-bottom: 20px; font-size: 18px; font-weight: bold; color: #555; }
        
        #game-container {
            position: relative;
            width: 450px;
            height: 500px;
            background-color: var(--board-bg);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border-radius: 4px;
            border: 2px solid var(--line-color);
            user-select: none;
        }
        canvas {
            position: absolute;
            top: 0; left: 0;
            z-index: 1;
        }
        #pieces-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 2;
        }
        .piece {
            position: absolute;
            width: 40px; height: 40px;
            border-radius: 50%;
            background: var(--piece-bg);
            border: 2px solid #c8a97e;
            box-shadow: 2px 3px 5px rgba(0,0,0,0.4);
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'KaiTi', 'STKaiti', serif;
            font-size: 24px;
            font-weight: bold;
            pointer-events: auto;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s;
            box-sizing: border-box;
        }
        .piece:hover { box-shadow: 2px 5px 8px rgba(0,0,0,0.6); }
        .piece.red { color: var(--red-piece); }
        .piece.black { color: var(--black-piece); }
        .piece.selected {
            box-shadow: 0 0 0 3px #27ae60, 2px 3px 5px rgba(0,0,0,0.4);
            transform: scale(1.05);
            z-index: 10;
        }

        .highlight {
            position: absolute;
            width: 16px; height: 16px;
            background-color: rgba(39, 174, 96, 0.8);
            border-radius: 50%;
            pointer-events: auto;
            cursor: pointer;
            z-index: 3;
            transform: translate(-50%, -50%);
        }
        .highlight:hover { background-color: rgba(39, 174, 96, 1); transform: translate(-50%, -50%) scale(1.2); }
    </style>
</head>
<body>

    <h1>中国象棋</h1>
    <div class="status-bar" id="status">玩家执红，请走棋</div>
    <div id="game-container">
        <canvas id="board-canvas" width="450" height="500"></canvas>
        <div id="pieces-layer"></div>
    </div>

<script>
// --- 初始化配置 ---
const CELL = 50;
const PADDING = 25;
const ROWS = 10;
const COLS = 9;

const CHARS = {
    'r': '車', 'h': '馬', 'e': '象', 'a': '士', 'g': '將', 'c': '砲', 's': '卒',
    'R': '車', 'H': '馬', 'E': '相', 'A': '仕', 'G': '帥', 'C': '炮', 'S': '兵'
};

const VALUES = {
    'r': -900, 'h': -400, 'e': -200, 'a': -200, 'g': -10000, 'c': -450, 's': -100,
    'R': 900,  'H': 400,  'E': 200,  'A': 200,  'G': 10000,  'C': 450,  'S': 100
};

// 移动方向常量（避免生成代码被截断）
const DIRS_CROSS =,,,];
const DIRS_DIAG =,,,];
const DIRS_ELEPHANT =,,,];
const DIRS_HORSE = [,,,,,,,];

let board = [,,,,,,,,,
];

let currentPlayer = 'red'; 
let isGameOver = false;
let selectedPiece = null;
let validMovesDisplay =[];

const piecesLayer = document.getElementById('pieces-layer');
const statusDiv = document.getElementById('status');

// --- 界面绘制 ---

function drawBoard() {
    const canvas = document.getElementById('board-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#5c3a21';
    ctx.lineWidth = 1.5;

    // 画横线
    for (let i = 0; i < ROWS; i++) {
        ctx.beginPath();
        ctx.moveTo(PADDING, PADDING + i * CELL);
        ctx.lineTo(PADDING + (COLS - 1) * CELL, PADDING + i * CELL);
        ctx.stroke();
    }
    // 画竖线 (避开楚河汉界)
    for (let j = 0; j < COLS; j++) {
        ctx.beginPath();
        ctx.moveTo(PADDING + j * CELL, PADDING);
        ctx.lineTo(PADDING + j * CELL, PADDING + 4 * CELL);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(PADDING + j * CELL, PADDING + 5 * CELL);
        ctx.lineTo(PADDING + j * CELL, PADDING + 9 * CELL);
        ctx.stroke();
    }
    // 连接边缘竖线
    ctx.beginPath(); ctx.moveTo(PADDING, PADDING + 4 * CELL); ctx.lineTo(PADDING, PADDING + 5 * CELL); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(PADDING + 8 * CELL, PADDING + 4 * CELL); ctx.lineTo(PADDING + 8 * CELL, PADDING + 5 * CELL); ctx.stroke();

    // 画九宫格斜线
    const drawCross = (r1, r2) => {
        ctx.beginPath(); ctx.moveTo(PADDING + 3 * CELL, PADDING + r1 * CELL); ctx.lineTo(PADDING + 5 * CELL, PADDING + r2 * CELL); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(PADDING + 5 * CELL, PADDING + r1 * CELL); ctx.lineTo(PADDING + 3 * CELL, PADDING + r2 * CELL); ctx.stroke();
    };
    drawCross(0, 2);
    drawCross(7, 9);

    // 楚河汉界文字
    ctx.fillStyle = '#5c3a21';
    ctx.font = "24px 'KaiTi', 'STKaiti', serif";
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText("楚 河", PADDING + 2 * CELL, PADDING + 4.5 * CELL);
    ctx.fillText("汉 界", PADDING + 6 * CELL, PADDING + 4.5 * CELL);
}

function renderPieces() {
    piecesLayer.innerHTML = '';
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            let p = board;
            if (p !== '.') {
                let div = document.createElement('div');
                div.className = `piece ${p === p.toUpperCase() ? 'red' : 'black'}`;
                div.innerText = CHARS;
                div.style.left = `${PADDING + c * CELL - 20}px`;
                div.style.top = `${PADDING + r * CELL - 20}px`;
                div.dataset.r = r;
                div.dataset.c = c;
                
                div.onclick = (e) => {
                    e.stopPropagation();
                    handlePieceClick(r, c, p);
                };
                piecesLayer.appendChild(div);
            }
        }
    }
}

// --- 游戏规则与逻辑 ---

const isRed = p => p !== '.' && p === p.toUpperCase();
const isBlack = p => p !== '.' && p === p.toLowerCase();
const isOpponent = (p, player) => p !== '.' && (player === 'red' ? isBlack(p) : isRed(p));
const isEmpty = p => p === '.';

function getValidMoves(b, r, c) {
    let moves =[];
    let p = b;
    if (isEmpty(p)) return moves;
    
    let player = isRed(p) ? 'red' : 'black';
    let type = p.toLowerCase();

    const add = (nr, nc) => {
        if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
            let target = b;
            if (isEmpty(target) || isOpponent(target, player)) {
                moves.push({r: nr, c: nc});
            }
        }
    };

    if (type === 'g') {
        DIRS_CROSS.forEach(d => {
            let nr = r + d, nc = c + d;
            if (nc >= 3 && nc <= 5) {
                if ((player === 'red' && nr >= 7 && nr <= 9) || (player === 'black' && nr >= 0 && nr <= 2)) add(nr, nc);
            }
        });
    }
    else if (type === 'a') {
        DIRS_DIAG.forEach(d => {
            let nr = r + d, nc = c + d;
            if (nc >= 3 && nc <= 5) {
                if ((player === 'red' && nr >= 7 && nr <= 9) || (player === 'black' && nr >= 0 && nr <= 2)) add(nr, nc);
            }
        });
    }
    else if (type === 'e') {
        DIRS_ELEPHANT.forEach(d => {
            let nr = r + d, nc = c + d;
            let eyenr = r + d/2, eyenc = c + d/2;
            if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && isEmpty(b)) {
                if ((player === 'red' && nr >= 5) || (player === 'black' && nr <= 4)) add(nr, nc);
            }
        });
    }
    else if (type === 'h') {
        DIRS_HORSE.forEach(d => {
            let nr = r + d, nc = c + d;
            let legR = r + (Math.abs(d) === 2 ? d/2 : 0);
            let legC = c + (Math.abs(d) === 2 ? d/2 : 0);
            if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && isEmpty(b)) {
                add(nr, nc);
            }
        });
    }
    else if (type === 'r' || type === 'c') {
        DIRS_CROSS.forEach(d => {
            let nr = r + d, nc = c + d;
            let jumped = false;
            while (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
                let target = b;
                if (type === 'r') {
                    if (isEmpty(target)) { add(nr, nc); }
                    else { if (isOpponent(target, player)) add(nr, nc); break; }
                } else { // 炮
                    if (!jumped) {
                        if (isEmpty(target)) add(nr, nc);
                        else jumped = true;
                    } else {
                        if (!isEmpty(target)) {
                            if (isOpponent(target, player)) add(nr, nc);
                            break;
                        }
                    }
                }
                nr += d; nc += d;
            }
        });
    }
    else if (type === 's') {
        let dir = player === 'red' ? -1 : 1;
        add(r + dir, c);
        if ((player === 'red' && r <= 4) || (player === 'black' && r >= 5)) {
            add(r, c - 1);
            add(r, c + 1);
        }
    }
    return moves;
}

function isFlyingGeneral(b) {
    let rG=-1, cG=-1, rg=-1, cg=-1;
    for(let i=0; i<ROWS; i++){
        for(let j=0; j<COLS; j++){
            if(b === 'G') { rG=i; cG=j; }
            if(b === 'g') { rg=i; cg=j; }
        }
    }
    if(cG === cg && cG !== -1) {
        let minR = Math.min(rG, rg);
        let maxR = Math.max(rG, rg);
        for(let i = minR + 1; i < maxR; i++) {
            if(b !== '.') return false;
        }
        return true; 
    }
    return false;
}

// --- 交互控制 ---

function clearHighlights() {
    validMovesDisplay.forEach(dom => dom.remove());
    validMovesDisplay =[];
}

function showHighlights(r, c, moves) {
    clearHighlights();
    document.querySelectorAll('.piece').forEach(el => el.classList.remove('selected'));
    
    let pieceDom = document.querySelector(`.piece`);
    if(pieceDom) pieceDom.classList.add('selected');

    moves.forEach(m => {
        let div = document.createElement('div');
        div.className = 'highlight';
        div.style.left = `${PADDING + m.c * CELL}px`;
        div.style.top = `${PADDING + m.r * CELL}px`;
        div.dataset.r = m.r;
        div.dataset.c = m.c;
        div.onclick = (e) => {
            e.stopPropagation();
            executeUserMove(r, c, m.r, m.c);
        };
        piecesLayer.appendChild(div);
        validMovesDisplay.push(div);
    });
}

function handlePieceClick(r, c, p) {
    if (isGameOver || currentPlayer !== 'red') return; 

    if (isRed(p)) {
        selectedPiece = {r, c};
        let moves = getValidMoves(board, r, c).filter(m => {
            let temp = board;
            board = board;
            board = '.';
            let invalid = isFlyingGeneral(board);
            board = board;
            board = temp;
            return !invalid;
        });
        showHighlights(r, c, moves);
    } else if (selectedPiece) {
        let targetHighlight = validMovesDisplay.find(dom => dom.dataset.r == r && dom.dataset.c == c);
        if(targetHighlight) {
            executeUserMove(selectedPiece.r, selectedPiece.c, r, c);
        }
    }
}

// 点空白处取消选中
piecesLayer.addEventListener('click', function(e) {
    clearHighlights();
    selectedPiece = null;
    document.querySelectorAll('.piece').forEach(el => el.classList.remove('selected'));
});

function executeUserMove(fromR, fromC, toR, toC) {
    clearHighlights();
    let targetPiece = board;
    board = board;
    board = '.';
    selectedPiece = null;
    
    renderPieces();
    
    if (targetPiece === 'g') {
        endGame('红方胜利！');
        return;
    }

    currentPlayer = 'black';
    statusDiv.innerText = "电脑思考中...";
    
    setTimeout(() => aiPlay(), 50);
}

// --- 简易 Minimax AI ---

function evaluate(b) {
    let score = 0, hasG = false, hasg = false;
    for(let i=0; i<ROWS; i++){
        for(let j=0; j<COLS; j++){
            let p = b;
            if(p !== '.') {
                if(p === 'G') hasG = true;
                if(p === 'g') hasg = true;
                let val = VALUES;
                if(p === 's' && i > 4) val -= 100;
                if(p === 'S' && i < 5) val += 100;
                score += val;
            }
        }
    }
    if(!hasG) return -100000;
    if(!hasg) return 100000;
    return score;
}

function getAllMoves(b, player) {
    let moves =[];
    for(let r=0; r<ROWS; r++){
        for(let c=0; c<COLS; c++){
            let p = b;
            if(p !== '.' && ((player === 'red' && isRed(p)) || (player === 'black' && isBlack(p)))) {
                let pieceMoves = getValidMoves(b, r, c);
                pieceMoves.forEach(pm => moves.push({from: {r, c}, to: {r: pm.r, c: pm.c}}));
            }
        }
    }
    return moves;
}

function minimax(b, depth, alpha, beta, isMaxPlayer) {
    let score = evaluate(b);
    if (score === -100000 || score === 100000) return score;
    if (depth === 0) return score;

    let moves = getAllMoves(b, isMaxPlayer ? 'red' : 'black');
    if(moves.length === 0) return isMaxPlayer ? -100000 : 100000;

    if (isMaxPlayer) {
        let maxEval = -Infinity;
        for (let m of moves) {
            let temp = b;
            b = b;
            b = '.';
            
            let ev = minimax(b, depth - 1, alpha, beta, false);
            
            b = b;
            b = temp;
            
            maxEval = Math.max(maxEval, ev);
            alpha = Math.max(alpha, ev);
            if (beta <= alpha) break;
        }
        return maxEval;
    } else {
        let minEval = Infinity;
        for (let m of moves) {
            let temp = b;
            b = b;
            b = '.';
            
            let ev = minimax(b, depth - 1, alpha, beta, true);
            
            b = b;
            b = temp;
            
            minEval = Math.min(minEval, ev);
            beta = Math.min(beta, ev);
            if (beta <= alpha) break;
        }
        return minEval;
    }
}

function aiPlay() {
    if(isGameOver) return;
    let bestScore = Infinity; 
    let bestMove = null;
    let moves = getAllMoves(board, 'black');
    
    // 随机打乱避免重复
    moves.sort(() => Math.random() - 0.5);
    
    for (let m of moves) {
        let temp = board;
        board = board;
        board = '.';
        
        if (isFlyingGeneral(board)) {
            board = board;
            board = temp;
            continue;
        }

        // 深度 2 层的 Alpha-Beta
        let score = minimax(board, 2, -Infinity, Infinity, true); 
        
        board = board;
        board = temp;
        
        if (score < bestScore) {
            bestScore = score;
            bestMove = m;
        }
    }

    if (bestMove) {
        let targetPiece = board;
        board = board;
        board = '.';
        renderPieces();
        
        if (targetPiece === 'G') {
            endGame('电脑胜利！');
            return;
        }
        
        currentPlayer = 'red';
        statusDiv.innerText = "玩家执红，请走棋";
    } else {
        endGame('红方胜利！(电脑无棋可走)');
    }
}

function endGame(msg) {
    isGameOver = true;
    statusDiv.innerText = msg;
    statusDiv.style.color = '#c0392b';
}

// 启动渲染
drawBoard();
renderPieces();
</script>
</body>
</html>
